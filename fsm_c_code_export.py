# Export dia finite state machines into C state machines
# Based on the work of Tomas Pospisek <tpo_deb@sourcepole.ch>
# http://www.sourcepole.ch/generating-state-machines-with-dia
# and Unai Est√©banez Sevilla
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <ulf.schmelzer@schmlzr.de> wrote this file. As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return Ulf Schmelzer
# ----------------------------------------------------------------------------
# Note: This code was created under the purpose to pass a labority in my studies
#       and it's not beauty. Sorry :()


import dia
import uml_stm_export
import os.path

class CDiagramRenderer(uml_stm_export.SimpleSTM):
    CODE_PREAMBLE = '''
/* 
 * Statemachine
 * Implementation of functions used to realise FSM
 * Author:  Machine generated by uml_stm_c_fsm_export.py script for dia
 *          If u edit this file make sure it will not be overwriten from dia
 *
 * License: "THE BEER-WARE LICENSE" (Revision 42) or what ever.
 *
 */

'''

    HEADER_PREAMBLE = '''
/* 
 * Statemachine
 * Headerfile of public functions used to realise FSM
 * Author:  Machine generated by uml_stm_c_fsm_export.py script for dia
 *          If u edit this file make sure it will not be overwritten from dia
 *
 * License: "THE BEER-WARE LICENSE" (Revision 42) or what ever.
 *
 */
'''

    def __init__(self):
        uml_stm_export.SimpleSTM.__init__(self)
        self.filename = ""

    def begin_render (self, data, filename):
        self.filename = filename
        uml_stm_export.SimpleSTM.parse(self, data)
                   
    def end_render(self) :
        stateMachineName = os.path.splitext(os.path.basename(self.filename))[0]
        ################################ Create .h file #####################################
        outputFile = os.path.splitext(self.filename)[0] + ".h"
        h = open(outputFile, "w")
        h.write(self.HEADER_PREAMBLE )
        h.write("#ifndef _%s__\n" % stateMachineName)
        h.write("#define _%s__\n" % stateMachineName)
        h.write("\n")

        h.write("/* All states as an enum */\n")
        h.write("typedef enum {\n\t")
        i = 0
        for key in self.states.keys():
            state = self.states[key]
            h.write(" %s" % state.name.upper())
            i = i + 1
            if(i < len(self.states.keys())):
                h.write(",")
        h.write("\n")
        h.write("} %sStates;\n" % stateMachineName)
        h.write("\n")
        h.write("/* One function for each state */\n")
        for key in self.states.keys():
            state = self.states[key]
            h.write("void %s(void);\n" % state.name.lower())
        h.write("\n")
        h.write("/* Setter and getters for the current state */\n")
        h.write("%sStates getCurrent%sState(void);\n" % (stateMachineName,stateMachineName))
        h.write("void setCurrent%sState(%sStates cs);\n" % (stateMachineName,stateMachineName))
        h.write("\n")
        h.write("/* Setter and getters for the previous state */\n")
        h.write("/* to detect a state transition              */\n")
        h.write("%sStates getLast%sState(void);\n" % (stateMachineName,stateMachineName))
        h.write("void setLastState%sState(%sStates cs);\n" % (stateMachineName,stateMachineName))
        h.write("\n")
        h.write("/* Initialization of the state machine, go to initial state */\n")
        h.write("/* This function have to be called at least once*/\n")
        h.write("void init%sStateMachine(void);\n" % stateMachineName)
        h.write("\n")
        h.write("void (*stateTable%s[%d])();\n" % (stateMachineName,len(self.states.keys())) )
        h.write("\n")
        h.write("#endif\n")
        h.close()

        ################################ Create .c file #####################################
        f = open(self.filename, "w")
        f.write(self.CODE_PREAMBLE)
        
        # include header file in c code
        f.write("#include \"%s.h\"\n" % stateMachineName) 
        f.write("// Place additional Variables here\n")

        f.write("static %sStates current%sState;\n" % (stateMachineName,stateMachineName))
        f.write("static %sStates last%sState;\n" % (stateMachineName,stateMachineName))

        # functions for setting and getting states
        f.write("//getter function to get current state\n")
        f.write("%sStates getCurrent%sState(void) {\n" % (stateMachineName,stateMachineName))
        f.write("\treturn current%sState;\n" % stateMachineName)
        f.write("}\n")
        f.write("//seter function to set current state\n")
        f.write("void setCurrent%sState(%sStates cs) {\n" % (stateMachineName,stateMachineName))
        f.write("\tcurrent%sState = cs;\n" % stateMachineName)
        f.write("}\n")
        f.write("//getter function to get last state\n")
        f.write("%sStates getLast%sState(void) {\n" % (stateMachineName,stateMachineName))
        f.write("\treturn last%sState;\n" % stateMachineName)
        f.write("}\n")
        f.write("// setter function to set last state\n")
        f.write("void setLast%sState(%sStates cs) {\n" % (stateMachineName,stateMachineName))
        f.write("\tlast%sState = cs;\n" % stateMachineName)
        f.write("}\n")




        initial_state = None
        for transition in self.transitions:
            # specialcase initial transition -> create initial state
            if(transition.source == "INITIAL_STATE"):
                initial_state = self.states[transition.target]


                f.write("// InitFunction for state machine\n")
                f.write("void init%sStateMachine(void) {\n" % stateMachineName)
                f.write("\tsetLast%sState(%s); /* force initial transition */ \n" % (stateMachineName, initial_state.name.upper()))
                f.write("\tsetCurrent%sState(%s); /* next after initial state */\n" % (stateMachineName, "-1"))
                f.write("}\n")
        # if there is no inital sate print error
        if (initial_state == None) :
            f.write("##########################ERROR########################\n")
            f.write("#there is no inital state please define inital state!!#\n")
            f.write("#######################################################\n")
            f.close()
            

        for key in self.states.keys():
            state = self.states[key]
            # initial_state has already been output
            # TODO: the fact that state can be None looks like a bug to me
            if( state != None ):
                f.write("// ****************************************************************************\n")
                f.write("// Place description of state \"%s\" here\n" % state.name)
                if(state.name == initial_state.name):
                    f.write("// INITIAL STATE\n")
                f.write("// Parameter: -\n")
                f.write("// Returns: -\n")
                f.write("void %s(void)\n" % state.name.lower())
                f.write("{\n")
                f.write("\t//On entry event\n")
                f.write("\tif (getCurrent%sState() != getLast%sState()) {\n" % (stateMachineName,stateMachineName))
                f.write("\t\t%s //onEntry activity\n" % state.iaction)
                f.write("\t\tsetLast%sState(getCurrent%sState()); //set last state to current to prevent entering this step again\n" % (stateMachineName,stateMachineName))
                f.write("\t}\n")
                f.write("\t\n")
                f.write("\t//do/actions\n")
                f.write("\t%s\n" % state.doaction)
                f.write("\t\n")
                f.write("\t//react on events like clk rising edge falling edge\n")
                first = 0
                
                usedTransitionsTriggers = [] # make a real copy of transitions to itrate later from the beginning
                # convert transition to if clauses
                for transition in self.transitions[:]:
                    #f.write("%s" % tran)
                    listGuards = []
                    firstGuard = 0
                    if(transition.source == state.name and transition.trigger not in usedTransitionsTriggers):
                        # make new list of transitions listening to listGuards trigger/event
                        for tmpGuard in self.transitions[:]:
                            if(tmpGuard.source == state.name):
                                if(tmpGuard.trigger == transition.trigger):
                                    listGuards.append(tmpGuard)
                                    self.transitions.remove(tmpGuard)

                        #write if for trigger
                        if(first == 0):
                            f.write("\tif( %s ){\n" % transition.trigger)
                            #f.write("\t\t//here we could place a guard condition          ")
                            f.write("\t\t//here we could prepare for a transition activity\n")
                            f.write("\t\t//transitionActivity = f0;\n")
                            first = 1
                        else:
                            f.write("\telse if( %s ){\n" % transition.trigger)
                        
                        #write if for guards
                        f.write("\t\t//guard condition\n")
                        for tmp in listGuards:
                            #overwrite empty guards with true
                            if tmp.guard:
                                tmpGuardString = tmp.guard
                            else:
                                tmpGuardString = "true"

                            if(firstGuard == 0):
                                firstGuard = 1
                                f.write("\t\tif( %s ){\n" % tmpGuardString) # if empty write true
                                f.write("\t\t\tsetCurrent%sState(%s); // next state\n" % (stateMachineName,tmp.target.upper()) )
                            else:
                                f.write("\t\telse if( %s ){\n" % tmpGuardString ) # if empty write true
                                f.write("\t\t\tsetCurrent%sState(%s); // next state\n" % (stateMachineName,tmp.target.upper()) )
                            f.write("\t\t}\n")
                        usedTransitionsTriggers.append(transition.trigger)

                        f.write("\t}\n")

                f.write("\t\n")
                f.write("\t\n")
                f.write("\t\n")
                f.write("\t//Here we could place the onExit activity\n")
                f.write("\t//Here we execute the transition activities, if any\n")                
                f.write("\tif (getCurrent%sState() != getLast%sState()) {\n" % (stateMachineName,stateMachineName))
                f.write("\t\t%s //onExit activity\n" % state.oaction)
                # todo: implement transition activitys
                # f.write("\t    switch (transitionActivity%s) {\n" % stateMachineName)
                # f.write("\t    case f0:\n")
                # f.write("\t        break;\n")
                # f.write("\t    case bar:\n")
                # f.write("\t        break;\n")
                # f.write("\t    default:\n")
                # f.write("\t        break;\n")
                # f.write("\t    }\n")
                f.write("\t}\n")
                f.write("}\n")


        for transition in self.transitions:
            # specialcase UNIVERSAL - this is a transition that's valid for all states
            if(transition.source == "INITIAL_STATE"):
                continue # skip the initial state transition
            f.write("    add_transition( stm, %s, %s, %s );\n" %
                (transition.source, transition.trigger, transition.target ))
            #   (transition.source, transition.trigger, transition.target, transition.action))

        f.write("/* A table with function pointers. Each state is represented by a single function */\n")
        f.write("/* It must be made sure that the order of the functions here correspond to the    */\n")
        f.write("/* order of the state enumeration in the %s.h header file.                   */\n" % stateMachineName)
        f.write("void (*stateTable%s[])() = {" % stateMachineName)
        i=0
        for key in self.states.keys():
            state = self.states[key]
            f.write(" %s" % state.name.lower())
            i = i + 1
            if(i < len(self.states.keys())):
                f.write(",")
        f.write("};\n\n")
        f.write("// call in main function like\n")
        f.write("// stateTable%s[getCurrent%sState()](); \n" % (stateMachineName,stateMachineName) )

        f.close()

        self.states = {}
        self.transitions = []

# dia-python keeps a reference to the renderer class and uses it on demand
dia.register_export("State Machine C-Code and Headerfile", "c and *.h", CDiagramRenderer())
